Влад Песчанский, [01.05.19 21:02]

program = 'Program', ID, '{',
    [ libraries section ],
    [ handlers section ],
    [ renderers section ],
    [ sources section ],
    [ sets section ],
    [ elements section ],
    [ tuples section ],
    [ aggregates section ],
    actions section,
'}';

//Libraries

libraries section = 'Libraries', '{', {library import}, '}';

library import = ID, ";";


handlers section = 'Handlers', '{', {item import}, '}';

renderers section = 'Renderers', '{', {item import}, '}';

sources section = 'Sources', '{', {item import}, '}';

sets section ='Sets', '{', {item import}, '}';

item import = ID, "from", expr, ";";


//Elements
elements section = 'Elements', '{', {element declaration}, '}';

element declaration = ID, assign, data, ";";

//Tuples
tuples section = 'Tuples', '{',
    {tuples section declaration},
'}';

tuples section declaration =
    ID, assign , data,';';

//Aggregates
aggregates section =  'Aggregates', '{', {aggr_decl}, '}';

aggr_decl = ID, assign , data ;

//Actions
actions section = 'Actions',"{", actions, "}";

action =  block_actions 
	| expr_st
	| sequence action 
	| download action 
	| upload action 
	| render action
	| if action 
	| cases action 
	| timeline action 
	| substitution action  ;

block_actions = "{", actions, "}";


sequence action = 'Sequence','{', actions,'}'; 

download action = 'Download', stream_names,
    'From', source_name,
    'With', handler_name,
';';

upload action = 'Upload', stream_names,
    'To', source_name,
    'With', handler_name,
';';



render action = 'Render', stream names, 'With', expr, ';';



timeline action = 'Timeline', timeline overload, block_actions


timeline overload = timeline expr
    | timeline as
    | timeline until
    | timeline while

timeline_expr = '(',expr, ':', expr, ':', expr,')';
timeline_as = 'As', ID ;
timeline_until = 'UNTIL', expr ;
timeline_while =  'WHILE', expr ;

ifAction = 'If', condition,
    'Then', actions block,
    [else action] ;
else action = 'Else', actions block;

cases action = 'Case', expression, 'Of',a
    cases branch, {cases branch},
    [else action] ;

cases branch = scalar value, ':', actions block;


substitution action = ' ', substitution with, 'For', substitution what,'When', condition,';';

expr_st = [expr], ";";  
block_st = "{", {st}, "}"; 
select_st = "if", "(", expr, ")", st, ["else", st];
iter_st = "while", "(", expr, ")", st;

expr = assign;
assign = log_or, assign_ap;
assign_ap = "=", log_or, assign_ap | EPS;
log_or = log_and, log_or_ap;
log_or_ap = "||", log_and, log_or_ap | EPS;
log_and = eq, log_and_ap;
log_and_ap = "&&", eq, log_and_ap | EPS;
eq = rel, eq_ap;

eq_ap = ("==" | "!="), rel, eq_ap | EPS;
rel = add, rel_ap;
rel_ap = ("<" | "<=" | ">" | ">="), add, rel_ap | EPS;
add = mult, add_ap;
add_ap = ("+" | "-"), mult, add_ap | EPS;
mult = unary, mult_ap;
mult_ap = ("*" | "/" | "%"), unary, mult_ap | EPS;

unary = primary
  | ("+" | "-" | "!"), primary;

primary = NUMBER
  | STRING
  | BOOL
  | var_or_call
  | parentheses;
var_or_call = ID, [fn_call];
parentheses = "(", expr, ")";
fn_call = "(", [arg_list], ")";

data = expr 
   | arr_init;

arr_init = "{", [arg_list], "}";
arg_list = expr, [",", arg_list];
